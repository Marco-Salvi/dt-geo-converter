package implicit

import (
	"database/sql"
	"dt-geo-db/cwl"
	"dt-geo-db/logger"
	"dt-geo-db/model"
)

// WorkflowToCWL converts a workflow to a CWL description.
func WorkflowToCWL(workflow Workflow, db *sql.DB) (cwl.Cwl, error) {
	logger.Debug("Starting WorkflowToCWL for workflow", workflow.Name)
	cwlInputs := make(map[string]any)
	cwlOutputs := make(map[string]cwl.Output)
	steps := make(map[string]cwl.Step)

	// Get the global input and outputs for this workflow
	dtst, err := model.GetDTSTRelationshipsForWF(db, workflow.Name)
	if err != nil {
		logger.Error("Error getting DT-ST relationships for workflow", workflow.Name, ":", err)
		return cwl.Cwl{}, err
	}

	// Build maps of dtIDs that are inputs or outputs.
	inputs, outputs := make(map[string]string), make(map[string]string)
	for _, relationship := range dtst {
		switch relationship.RelationshipType {
		case "is input to", "is the input to", "is input from":
			// No action for inputs at this stage.
			continue
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			outputs[relationship.DTID] = relationship.DTID
		default:
			logger.Info("Unknown relationship type when converting to CWL (DT-ST):", relationship.RelationshipType)
		}
	}

	// Inputs are all the datasets that are not output of anything.
	dts, err := model.GetDTsForWF(db, workflow.Name)
	if err != nil {
		logger.Error("Error getting datasets for workflow", workflow.Name, ":", err)
		return cwl.Cwl{}, err
	}
	for _, dt := range dts {
		if _, ok := outputs[dt.ID]; !ok {
			inputs[dt.ID] = dt.ID
		}
	}

	// To handle multiple output sources, we create a temporary map.
	outputSources := make(map[string][]string)
	// For conditionally adding the requirement.
	multipleSourcesFound := false

	// For each dataset, calculate the source.
	for _, dt := range dts {
		dsources, err := getDTSourceWorkflow(workflow, dt.ID)
		if err != nil {
			logger.Error("Error getting DT sources for dataset", dt.ID, ":", err)
			return cwl.Cwl{}, err
		}
		if len(dsources) == 0 {
			logger.Debug("No sources found for dataset", dt.ID)
			continue
		}

		// For inputs, use the first available source.
		if _, ok := inputs[dt.ID]; ok {
			inputs[dt.ID] = dsources[0] + "/" + inputs[dt.ID]
			logger.Debug("Input", dt.ID, "assigned source", dsources[0])
		}

		// For outputs, build a list of all sources.
		if _, ok := outputs[dt.ID]; ok {
			sources := []string{}
			for _, src := range dsources {
				sources = append(sources, src+"/"+outputs[dt.ID])
			}
			// If more than one source, set the flag.
			if len(sources) > 1 {
				multipleSourcesFound = true
				logger.Info("Dataset", dt.ID, "has multiple sources:", sources)
			}
			outputSources[dt.ID] = sources
		}
	}

	// Build the CWL inputs.
	for dt := range inputs {
		cwlInputs[dt] = cwl.Input{Type: cwl.Directory}
	}

	// Build the CWL outputs.
	for dt, dtValue := range outputs {
		if sources, exists := outputSources[dt]; exists && len(sources) > 1 {
			newType := cwl.IOType(string(cwl.Directory) + "[]")
			cwlOutputs[dt] = cwl.Output{
				Type:         newType,
				OutputSource: []any{},
				LinkMerge:    "merge_flattened",
			}
			tmp := cwlOutputs[dt]
			for _, src := range sources {
				tmp.OutputSource = append(tmp.OutputSource.([]any), src)
			}
			cwlOutputs[dt] = tmp
			logger.Debug("Output", dt, "assigned multiple sources:", sources)
		} else if sources, exists := outputSources[dt]; exists {
			cwlOutputs[dt] = cwl.Output{
				Type:         cwl.Directory,
				OutputSource: []any{sources[0]},
			}
			logger.Debug("Output", dt, "assigned single source:", sources[0])
		} else {
			cwlOutputs[dt] = cwl.Output{
				Type:         cwl.Directory,
				OutputSource: []any{dtValue},
			}
			logger.Debug("Output", dt, "has fallback source:", dtValue)
		}
	}

	// Get all the non-dataset nodes (steps) in the workflow.
	sts, err := workflow.getVertices()
	if err != nil {
		logger.Error("Error getting vertices from workflow", workflow.Name, ":", err)
		return cwl.Cwl{}, err
	}

	// Calculate the steps, their inputs and outputs.
	for _, step := range sts {
		stepInputs := make(map[string]string)
		var stepOutputs []string

		relationships, err := model.GetDTSTRelationships(db, step.Id)
		if err != nil {
			logger.Error("Error getting DT-ST relationships for step", step.Id, ":", err)
			return cwl.Cwl{}, err
		}

		for _, relationship := range relationships {
			dsources, err := getDTSourceWorkflow(workflow, relationship.DTID)
			if err != nil {
				logger.Error("Error getting DT sources for relationship in step", step.Id, ":", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if len(dsources) > 0 {
				stepInput = dsources[0] + "/" + relationship.DTID
			}

			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.STID+"/"+relationship.DTID)
			default:
				logger.Info("Unknown relationship type when converting to CWL (DT-ST):", relationship.RelationshipType)
			}
		}

		if len(stepInputs) == 0 && len(stepOutputs) == 0 {
			logger.Info("WARNING: Step", step.Id, "has no inputs and no outputs, are you sure it's correct?")
		}

		steps[step.Id] = cwl.Step{
			Run: step.Id + ".cwl",
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	// Build the requirements map: add MultipleInputFeatureRequirement only if needed.
	reqs := map[string]map[string]string{
		"SubworkflowFeatureRequirement": {},
	}
	if multipleSourcesFound {
		reqs["MultipleInputFeatureRequirement"] = map[string]string{}
		logger.Debug("MultipleInputFeatureRequirement added to CWL requirements")
	}

	logger.Debug("WorkflowToCWL completed for workflow", workflow.Name)
	return cwl.Cwl{
		CWLVersion:   "v1.2",
		Class:        "Workflow",
		Inputs:       cwlInputs,
		Outputs:      cwlOutputs,
		Requirements: reqs,
		Steps:        steps,
	}, nil
}

// StepToCWL converts a step to a CWL description.
func StepToCWL(step Step, db *sql.DB) (cwl.Cwl, error) {
	logger.Debug("Starting StepToCWL for step", step.Id)
	inputs := make(map[string]any)
	outputs := make(map[string]cwl.Output)
	steps := make(map[string]cwl.Step)

	// Get the global input and outputs for this step.
	dtst, err := model.GetDTSTRelationships(db, step.Id)
	if err != nil {
		logger.Error("Error getting DT-ST relationships for step", step.Id, ":", err)
		return cwl.Cwl{}, err
	}

	// Process inputs and outputs.
	for _, relationship := range dtst {
		switch relationship.RelationshipType {
		case "is input to", "is the input to":
			if _, ok := inputs[relationship.DTID]; !ok {
				inputs[relationship.DTID] = cwl.Directory
			} else {
				logger.Error("Duplicate input detected for dataset", relationship.DTID, "in step", step.Id)
			}
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			if out, ok := outputs[relationship.DTID]; ok {
				// If this is the first time a duplicate is found, convert type to an array.
				if len(out.OutputSource.([]any)) == 1 {
					out.Type = cwl.IOType(string(cwl.Directory) + "[]")
				}
				sources := out.OutputSource.([]any)
				sources = append(sources, relationship.STID+"/"+relationship.DTID)
				out.OutputSource = sources
				out.LinkMerge = "merge_flattened"
				outputs[relationship.DTID] = out
				logger.Debug("Appending additional output source for dataset", relationship.DTID)
			} else {
				outputs[relationship.DTID] = cwl.Output{
					Type:         cwl.Directory,
					OutputSource: []any{relationship.STID + "/" + relationship.DTID},
				}
				logger.Debug("Assigning initial output source for dataset", relationship.DTID)
			}
		default:
			logger.Info("Unknown relationship type when converting to CWL (DT-ST):", relationship.RelationshipType)
		}
	}

	// Process inner steps.
	_, sts, sss, err := step.getVertices()
	if err != nil {
		logger.Error("Error getting vertices for step", step.Id, ":", err)
		return cwl.Cwl{}, err
	}

	for _, innerStep := range sss {
		stepInputs := make(map[string]string)
		var stepOutputs []string
		runInputs := make(map[string]cwl.IOType)
		runOutputs := make(map[string]cwl.IOType)

		// Get dataset relationships for this inner step.
		dtss, err := model.GetDTSSRelationshipsForSS(db, innerStep)
		if err != nil {
			logger.Error("Error getting DT-SS relationships for inner step", innerStep, ":", err)
			return cwl.Cwl{}, err
		}
		for _, relationship := range dtss {
			dsources, err := getDTSource(step, relationship.DTID)
			if err != nil {
				logger.Error("Error getting DT sources for dataset", relationship.DTID, "in inner step", innerStep, ":", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if len(dsources) > 0 {
				stepInput = dsources[0] + "/" + relationship.DTID
			}

			// Update global outputs if dataset is present.
			if _, ok := outputs[relationship.DTID]; ok {
				out := cwl.Output{
					Type:         cwl.Directory,
					OutputSource: []any{stepInput},
				}
				outputs[relationship.DTID] = out
				logger.Debug("Updating global output source for dataset", relationship.DTID, "in inner step", innerStep)
			}
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
				runInputs[relationship.DTID] = cwl.Directory
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			default:
				logger.Info("Unknown relationship type when converting to CWL (DT-SS):", relationship.RelationshipType)
			}
		}

		if len(stepInputs) == 0 && len(stepOutputs) == 0 {
			logger.Info("WARNING: Inner step", step.Id, "has no inputs and no outputs; please verify correctness")
		}

		steps[innerStep] = cwl.Step{
			Run: cwl.Run{
				Class:   "Operation",
				Inputs:  runInputs,
				Outputs: runOutputs,
			},
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	for _, innerStep := range sts {
		stepInputs := make(map[string]string)
		var stepOutputs []string
		runInputs := make(map[string]cwl.IOType)
		runOutputs := make(map[string]cwl.IOType)

		for _, relationship := range dtst {
			dsources, err := getDTSource(step, relationship.DTID)
			if err != nil {
				logger.Error("Error getting DT sources for dataset", relationship.DTID, "in step", step.Id, ":", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if len(dsources) > 0 {
				stepInput = dsources[0] + "/" + relationship.DTID
			}

			// Update global outputs if dataset is present.
			if _, ok := outputs[relationship.DTID]; ok {
				out := cwl.Output{
					Type:         cwl.Directory,
					OutputSource: []any{stepInput},
				}
				outputs[relationship.DTID] = out
				logger.Debug("Updating global output source for dataset", relationship.DTID, "in step", step.Id)
			}
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
				runInputs[relationship.DTID] = cwl.Directory
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.STID+"/"+relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			default:
				logger.Info("Unknown relationship type when converting to CWL (DT-SS):", relationship.RelationshipType)
			}
		}

		steps[innerStep] = cwl.Step{
			Run: cwl.Run{
				Class:   "Operation",
				Inputs:  runInputs,
				Outputs: runOutputs,
			},
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	logger.Debug("StepToCWL completed for step", step.Id)
	return cwl.Cwl{
		CWLVersion: "v1.2",
		Class:      "Workflow",
		Inputs:     inputs,
		Outputs:    outputs,
		Steps:      steps,
	}, nil
}

// getDTSource returns all the sources that generate the given dataset in a step.
func getDTSource(step Step, dt string) ([]string, error) {
	predecessorsMap, err := step.Graph.PredecessorMap()
	if err != nil {
		logger.Error("Error retrieving predecessor map for step", step.Id, ":", err)
		return nil, err
	}

	predecessors, exists := predecessorsMap[dt]
	if !exists || len(predecessors) == 0 {
		logger.Debug("No predecessors found for dataset", dt, "in step", step.Id)
		return nil, nil
	}

	sources := []string{}
	for predID := range predecessors {
		sources = append(sources, predID)
	}

	if len(sources) > 1 {
		logger.Debug("Dataset", dt, "is generated from multiple sources:", sources)
	}

	return sources, nil
}

// getDTSourceWorkflow returns all the sources that generate the given dataset in a workflow.
func getDTSourceWorkflow(workflow Workflow, dt string) ([]string, error) {
	predecessorsMap, err := workflow.Graph.PredecessorMap()
	if err != nil {
		logger.Error("Error retrieving predecessor map for workflow", workflow.Name, ":", err)
		return nil, err
	}

	predecessors, exists := predecessorsMap[dt]
	if !exists || len(predecessors) == 0 {
		logger.Debug("No predecessors found for dataset", dt, "in workflow", workflow.Name)
		return nil, nil
	}

	sources := []string{}
	for predID := range predecessors {
		sources = append(sources, predID)
	}

	if len(sources) > 1 {
		logger.Debug("Dataset", dt, "is generated from multiple sources in workflow", workflow.Name, ":", sources)
	}

	return sources, nil
}
