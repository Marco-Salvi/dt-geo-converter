package implicit

import (
	"database/sql"
	"dt-geo-converter/cwl"
	"dt-geo-converter/logger"
	"dt-geo-converter/model"
)

// WorkflowToCWL converts a workflow to a CWL description.
func WorkflowToCWL(workflow Workflow, db *sql.DB) (cwl.Cwl, error) {
	logger.Debug("Starting conversion for workflow", workflow.Name)
	cwlInputs := make(map[string]any)
	cwlOutputs := make(map[string]cwl.Output)
	steps := make(map[string]cwl.Step)

	// Retrieve DT-ST relationships for the workflow.
	dtst, err := model.GetDTSTRelationshipsForWF(db, workflow.Name)
	if err != nil {
		logger.Error("Failed to retrieve DT-ST relationships for workflow", workflow.Name, ":", err)
		return cwl.Cwl{}, err
	}

	// Build maps of dataset IDs for inputs and outputs.
	inputs, outputs := make(map[string]string), make(map[string]string)
	for _, relationship := range dtst {
		switch relationship.RelationshipType {
		case "is input to", "is the input to", "is input from":
			// Inputs will be processed later.
			continue
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			outputs[relationship.DTID] = relationship.DTID
		default:
			logger.Debug("Unknown DT-ST relationship type:", relationship.RelationshipType)
		}
	}

	// Identify inputs as datasets that are not outputs.
	dts, err := model.GetDTsForWF(db, workflow.Name)
	if err != nil {
		logger.Error("Failed to retrieve datasets for workflow", workflow.Name, ":", err)
		return cwl.Cwl{}, err
	}
	for _, dt := range dts {
		if _, found := outputs[dt.ID]; !found {
			inputs[dt.ID] = dt.ID
		}
	}

	// Process dataset sources and determine if multiple sources are detected.
	outputSources := make(map[string][]string)
	multipleSourcesFound := false
	for _, dt := range dts {
		ds, err := getDTSourceWorkflow(workflow, dt.ID)
		if err != nil {
			logger.Error("Error obtaining sources for dataset", dt.ID, ":", err)
			return cwl.Cwl{}, err
		}
		if len(ds) == 0 {
			logger.Debug("No sources found for dataset", dt.ID)
			continue
		}

		// For inputs, assign the first available source.
		if _, isInput := inputs[dt.ID]; isInput {
			inputs[dt.ID] = ds[0] + "/" + inputs[dt.ID]
			logger.Debug("Input dataset", dt.ID, "assigned source", ds[0])
		}

		// For outputs, collect all available sources.
		if _, isOutput := outputs[dt.ID]; isOutput {
			var sources []string
			for _, src := range ds {
				sources = append(sources, src+"/"+outputs[dt.ID])
			}
			if len(sources) > 1 {
				multipleSourcesFound = true
				logger.Debug("Multiple output sources detected for dataset", dt.ID, "sources", sources)
			}
			outputSources[dt.ID] = sources
		}
	}

	// Build CWL inputs.
	for dt := range inputs {
		cwlInputs[dt] = cwl.Input{Type: cwl.Directory}
	}

	// Build CWL outputs.
	for dt, dtVal := range outputs {
		if sources, exists := outputSources[dt]; exists && len(sources) > 1 {
			newType := cwl.IOType(string(cwl.Directory) + "[]")
			cwlOutputs[dt] = cwl.Output{
				Type:         newType,
				OutputSource: []any{},
				LinkMerge:    "merge_flattened",
			}
			tmp := cwlOutputs[dt]
			for _, src := range sources {
				tmp.OutputSource = append(tmp.OutputSource.([]any), src)
			}
			cwlOutputs[dt] = tmp
			logger.Debug("Output dataset", dt, "assigned multiple sources", sources)
		} else if sources, exists := outputSources[dt]; exists {
			cwlOutputs[dt] = cwl.Output{
				Type:         cwl.Directory,
				OutputSource: []any{sources[0]},
			}
			logger.Debug("Output dataset", dt, "assigned single source", sources[0])
		} else {
			cwlOutputs[dt] = cwl.Output{
				Type:         cwl.Directory,
				OutputSource: []any{dtVal},
			}
			logger.Debug("Output dataset", dt, "using fallback source", dtVal)
		}
	}

	// Retrieve workflow steps (non-dataset vertices).
	sts, err := workflow.getVertices()
	if err != nil {
		logger.Error("Failed to retrieve workflow vertices for", workflow.Name, ":", err)
		return cwl.Cwl{}, err
	}

	// Process each step.
	for _, step := range sts {
		stepInputs := make(map[string]string)
		var stepOutputs []string

		relationships, err := model.GetDTSTRelationships(db, step.Id)
		if err != nil {
			logger.Error("Error retrieving DT-ST relationships for step", step.Id, ":", err)
			return cwl.Cwl{}, err
		}

		for _, relationship := range relationships {
			ds, err := getDTSourceWorkflow(workflow, relationship.DTID)
			if err != nil {
				logger.Error("Error obtaining sources for dataset", relationship.DTID, "in step", step.Id, ":", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if len(ds) > 0 {
				stepInput = ds[0] + "/" + relationship.DTID
			}

			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.STID+"/"+relationship.DTID)
			default:
				logger.Debug("Unrecognized DT-ST relationship type:", relationship.RelationshipType)
			}
		}

		if len(stepInputs) == 0 && len(stepOutputs) == 0 {
			logger.Warning("Step", step.Id, "has no inputs or outputs")
		}

		steps[step.Id] = cwl.Step{
			Run: step.Id + ".cwl",
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	// Build requirements; include MultipleInputFeatureRequirement only if needed.
	reqs := map[string]map[string]string{
		"SubworkflowFeatureRequirement": {},
	}
	if multipleSourcesFound {
		reqs["MultipleInputFeatureRequirement"] = map[string]string{}
		logger.Debug("Added MultipleInputFeatureRequirement to CWL requirements")
	}

	logger.Debug("Completed conversion for workflow", workflow.Name)
	return cwl.Cwl{
		CWLVersion:   "v1.2",
		Class:        "Workflow",
		Inputs:       cwlInputs,
		Outputs:      cwlOutputs,
		Requirements: reqs,
		Steps:        steps,
	}, nil
}

// StepToCWL converts a step to a CWL description.
func StepToCWL(step Step, db *sql.DB) (cwl.Cwl, error) {
	logger.Debug("Starting conversion for step", step.Id)
	inputs := make(map[string]any)
	outputs := make(map[string]cwl.Output)
	steps := make(map[string]cwl.Step)

	// Retrieve DT-ST relationships for the step.
	dtst, err := model.GetDTSTRelationships(db, step.Id)
	if err != nil {
		logger.Error("Failed to retrieve DT-ST relationships for step", step.Id, ":", err)
		return cwl.Cwl{}, err
	}

	// Process inputs and outputs.
	for _, relationship := range dtst {
		switch relationship.RelationshipType {
		case "is input to", "is the input to":
			if _, exists := inputs[relationship.DTID]; !exists {
				inputs[relationship.DTID] = cwl.Directory
			} else {
				logger.Warning("Duplicate input detected for dataset", relationship.DTID, "in step", step.Id)
			}
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			if out, exists := outputs[relationship.DTID]; exists {
				// Convert type to an array on first duplicate.
				if len(out.OutputSource.([]any)) == 1 {
					out.Type = cwl.IOType(string(cwl.Directory) + "[]")
				}
				sources := out.OutputSource.([]any)
				sources = append(sources, relationship.STID+"/"+relationship.DTID)
				out.OutputSource = sources
				out.LinkMerge = "merge_flattened"
				outputs[relationship.DTID] = out
				logger.Debug("[StepToCWL] Appended additional output source for dataset", relationship.DTID)
			} else {
				outputs[relationship.DTID] = cwl.Output{
					Type:         cwl.Directory,
					OutputSource: []any{relationship.STID + "/" + relationship.DTID},
				}
				logger.Debug("Assigned initial output source for dataset", relationship.DTID)
			}
		default:
			logger.Debug("Unrecognized DT-ST relationship type:", relationship.RelationshipType)
		}
	}

	// Retrieve inner and outer steps.
	_, sts, sss, err := step.getVertices()
	if err != nil {
		logger.Error("Failed to retrieve vertices for step", step.Id, ":", err)
		return cwl.Cwl{}, err
	}

	// Process inner steps.
	for _, innerStep := range sss {
		stepInputs := make(map[string]string)
		var stepOutputs []string
		runInputs := make(map[string]cwl.IOType)
		runOutputs := make(map[string]cwl.IOType)

		dtss, err := model.GetDTSSRelationshipsForSS(db, innerStep)
		if err != nil {
			logger.Error("Failed to retrieve DT-SS relationships for inner step", innerStep, ":", err)
			return cwl.Cwl{}, err
		}
		for _, relationship := range dtss {
			ds, err := getDTSource(step, relationship.DTID)
			if err != nil {
				logger.Error("Error obtaining sources for dataset", relationship.DTID, "in inner step", innerStep, ":", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if len(ds) > 0 {
				stepInput = ds[0] + "/" + relationship.DTID
			}

			// Update global outputs if applicable.
			if _, exists := outputs[relationship.DTID]; exists {
				out := cwl.Output{
					Type:         cwl.Directory,
					OutputSource: []any{stepInput},
				}
				outputs[relationship.DTID] = out
				logger.Debug("Updated global output for dataset", relationship.DTID, "in inner step", innerStep)
			}

			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
				runInputs[relationship.DTID] = cwl.Directory
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			default:
				logger.Debug("Unrecognized DT-SS relationship type:", relationship.RelationshipType)
			}
		}

		if len(stepInputs) == 0 && len(stepOutputs) == 0 {
			logger.Warning("Inner step", step.Id, "has no inputs or outputs; please verify its configuration")
		}

		steps[innerStep] = cwl.Step{
			Run: cwl.Run{
				Class:   "Operation",
				Inputs:  runInputs,
				Outputs: runOutputs,
			},
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	// Process outer steps.
	for _, outerStep := range sts {
		stepInputs := make(map[string]string)
		var stepOutputs []string
		runInputs := make(map[string]cwl.IOType)
		runOutputs := make(map[string]cwl.IOType)

		for _, relationship := range dtst {
			ds, err := getDTSource(step, relationship.DTID)
			if err != nil {
				logger.Error("Error obtaining sources for dataset", relationship.DTID, "in step", step.Id, ":", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if len(ds) > 0 {
				stepInput = ds[0] + "/" + relationship.DTID
			}

			// Update global outputs if dataset exists.
			if _, exists := outputs[relationship.DTID]; exists {
				out := cwl.Output{
					Type:         cwl.Directory,
					OutputSource: []any{stepInput},
				}
				outputs[relationship.DTID] = out
				logger.Debug("Updated global output for dataset", relationship.DTID, "in step", step.Id)
			}

			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
				runInputs[relationship.DTID] = cwl.Directory
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.STID+"/"+relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			default:
				logger.Debug("Unrecognized DT-SS relationship type:", relationship.RelationshipType)
			}
		}

		steps[outerStep] = cwl.Step{
			Run: cwl.Run{
				Class:   "Operation",
				Inputs:  runInputs,
				Outputs: runOutputs,
			},
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	logger.Debug("Completed conversion for step", step.Id)
	return cwl.Cwl{
		CWLVersion: "v1.2",
		Class:      "Workflow",
		Inputs:     inputs,
		Outputs:    outputs,
		Steps:      steps,
	}, nil
}

// getDTSource returns all sources generating the given dataset within a step.
func getDTSource(step Step, dt string) ([]string, error) {
	predecessorsMap, err := step.Graph.PredecessorMap()
	if err != nil {
		logger.Error("Failed to retrieve predecessor map for step", step.Id, ":", err)
		return nil, err
	}

	predecessors, exists := predecessorsMap[dt]
	if !exists || len(predecessors) == 0 {
		logger.Debug("No predecessors found for dataset", dt, "in step", step.Id)
		return nil, nil
	}

	var sources []string
	for predID := range predecessors {
		sources = append(sources, predID)
	}

	if len(sources) > 1 {
		logger.Debug("Dataset", dt, "generated from multiple sources:", sources)
	}

	return sources, nil
}

// getDTSourceWorkflow returns all sources generating the given dataset within a workflow.
func getDTSourceWorkflow(workflow Workflow, dt string) ([]string, error) {
	predecessorsMap, err := workflow.Graph.PredecessorMap()
	if err != nil {
		logger.Error("Failed to retrieve predecessor map for workflow", workflow.Name, ":", err)
		return nil, err
	}

	predecessors, exists := predecessorsMap[dt]
	if !exists || len(predecessors) == 0 {
		logger.Debug("No predecessors found for dataset", dt, "in workflow", workflow.Name)
		return nil, nil
	}

	var sources []string
	for predID := range predecessors {
		sources = append(sources, predID)
	}

	if len(sources) > 1 {
		logger.Debug("Dataset", dt, "generated from multiple sources in workflow", workflow.Name, ":", sources)
	}

	return sources, nil
}
