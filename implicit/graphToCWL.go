package implicit

import (
	"database/sql"
	"dt-geo-db/cwl"
	"dt-geo-db/orms"
	"fmt"
	"log"
	"strings"
)

func StepToCWL(step Step, db *sql.DB) (cwl.Cwl, error) {
	inputs := make(map[string]cwl.IOType)
	outputs := make(map[string]cwl.Output)
	steps := make(map[string]cwl.Step)

	// Get the global input and outputs for this step
	dtst, err := orms.GetDTSTRelationships(db, step.Id)
	if err != nil {
		return cwl.Cwl{}, err
	}

	// inputs and outputs
	for _, relationship := range dtst {
		switch relationship.RelationshipType {
		case "is input to", "is the input to":
			_, ok := inputs[relationship.DTID]
			if !ok {
				inputs[relationship.DTID] = cwl.Directory
			} else {
				log.Println("Some kind of error")
			}
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			_, ok := outputs[relationship.DTID]
			if !ok {
				outputs[relationship.DTID] = cwl.Output{
					Type: cwl.Directory,
					// TODO this should be the SSID / the DTID not the STID
					OutputSource: relationship.STID + "/" + relationship.DTID,
				}
			} else {
				log.Println("Some kind of error")
			}
		default:
			log.Printf("Unknown relationship type when converting to CWL (DT-ST): %s", relationship.RelationshipType)
		}
	}

	// steps
	vertices, err := step.getVertices()
	if err != nil {
		return cwl.Cwl{}, err
	}

	for _, innerStep := range vertices {
		// skip the vertices that are not steps
		if strings.HasPrefix(innerStep, "DT") {
			continue
		}
		stepInputs := make(map[string]string)
		var stepOutputs []string
		runInputs := make(map[string]cwl.IOType)
		runOutputs := make(map[string]cwl.IOType)

		// get the dataset dtst with this ss
		dtss, err := orms.GetDTSSRelationshipsForSS(db, innerStep)
		if err != nil {
			return cwl.Cwl{}, err
		}
		for _, relationship := range dtss {
			datasetSource, err := getDTSource(step, relationship.DTID)
			if err != nil {
				log.Printf("error %s", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if datasetSource != "" {
				stepInput = datasetSource + "/" + relationship.DTID
			}
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
				runInputs[relationship.DTID] = cwl.Directory
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.SSID+"/"+relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			default:
				log.Printf("Unknown relationship type when converting to CWL (DT-SS): %s", relationship.RelationshipType)
			}
		}

		steps[innerStep] = cwl.Step{
			Run: cwl.Run{
				Class:   "Operation",
				Inputs:  runInputs,
				Outputs: runOutputs,
			},
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	return cwl.Cwl{
		CWLVersion: "v1.2",
		Class:      "Workflow",
		Inputs:     inputs,
		Outputs:    outputs,
		Steps:      steps,
	}, nil
}

func getDTSource(step Step, dt string) (string, error) {
	predecessorsMap, err := step.Graph.PredecessorMap()
	if err != nil {
		return "", err
	}

	predecessors, exists := predecessorsMap[dt]
	if !exists || len(predecessors) == 0 {
		return "", nil
	}

	if len(predecessors) > 1 {
		log.Printf("WARNING: DT %s is generated from multiple SSs, choosing one at random (this is something that has to be fixed in the spreadsheet description)", dt)
	}

	for predID := range predecessors {
		return predID, nil
	}
	return "", fmt.Errorf("this error should never happen")
}
