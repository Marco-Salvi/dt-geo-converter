package implicit

import (
	"database/sql"
	"dt-geo-db/cwl"
	"dt-geo-db/orms"
	"log"
)

func WorkflowToCWL(workflow Workflow, db *sql.DB) (cwl.Cwl, error) {
	cwlInputs := make(map[string]cwl.IOType)
	cwlOutputs := make(map[string]cwl.Output)
	steps := make(map[string]cwl.Step)

	// Get the global input and outputs for this step
	dtst, err := orms.GetDTSTRelationshipsForWF(db, workflow.Name)
	if err != nil {
		return cwl.Cwl{}, err
	}

	// inputs and outputs
	inputs, outputs := make(map[string]string), make(map[string]string)
	// outputs are all the datasets that are output of something
	for _, relationship := range dtst {
		switch relationship.RelationshipType {
		case "is input to", "is the input to", "is input from":
			continue
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			outputs[relationship.DTID] = relationship.DTID
		default:
			log.Printf("Unknown relationship type when converting to CWL (DT-ST): %s", relationship.RelationshipType)
		}
	}

	// inputs are all the datasets that are not output of anything
	dts, err := orms.GetDTsForWF(db, workflow.Name)
	if err != nil {
		return cwl.Cwl{}, err
	}
	for _, dt := range dts {
		_, ok := outputs[dt.ID]
		if !ok {
			inputs[dt.ID] = dt.ID
		}
	}

	// for each dataset calculate the source
	for _, dt := range dts {
		datasetSource, err := getDTSourceWorkflow(workflow, dt.ID)
		if err != nil {
			return cwl.Cwl{}, err
		}
		if datasetSource == "" {
			continue
		}

		_, ok := inputs[dt.ID]
		if ok {
			inputs[dt.ID] = datasetSource + "/" + inputs[dt.ID]
		}

		_, ok = outputs[dt.ID]
		if ok {
			outputs[dt.ID] = datasetSource + "/" + outputs[dt.ID]
		}
	}

	// build the objects for the cwl inputs and outputs
	for dt, dtSource := range inputs {
		cwlInputs[dt] = cwl.IOType(dtSource)
	}
	for dt, dtSource := range outputs {
		cwlOutputs[dt] = cwl.Output{
			Type:         cwl.Directory,
			OutputSource: dtSource,
		}
	}

	// get all the nodes in this wf that are not datasets
	sts, err := workflow.getVertices()
	if err != nil {
		return cwl.Cwl{}, err
	}

	// calculate the steps, their inputs and their outputs
	for _, step := range sts {
		stepInputs := make(map[string]string)
		var stepOutputs []string

		relationships, err := orms.GetDTSTRelationships(db, step.Id)
		if err != nil {
			return cwl.Cwl{}, err
		}

		for _, relationship := range relationships {
			datasetSource, err := getDTSourceWorkflow(workflow, relationship.DTID)
			if err != nil {
				log.Printf("error %s", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if datasetSource != "" {
				stepInput = datasetSource + "/" + relationship.DTID
			}

			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.STID+"/"+relationship.DTID)
			default:
				log.Printf("Unknown relationship type when converting to CWL (DT-ST): %s", relationship.RelationshipType)
			}
		}

		steps[step.Id] = cwl.Step{
			Run: step.Id + ".cwl",
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	return cwl.Cwl{
		CWLVersion: "v1.2",
		Class:      "Workflow",
		Inputs:     cwlInputs,
		Outputs:    cwlOutputs,
		Requirements: map[string]map[string]string{
			"SubworkflowFeatureRequirement": {},
		},
		Steps: steps,
	}, nil
}

func StepToCWL(step Step, db *sql.DB) (cwl.Cwl, error) {
	inputs := make(map[string]cwl.IOType)
	outputs := make(map[string]cwl.Output)
	steps := make(map[string]cwl.Step)

	// Get the global input and outputs for this step
	dtst, err := orms.GetDTSTRelationships(db, step.Id)
	if err != nil {
		return cwl.Cwl{}, err
	}

	// inputs and outputs
	for _, relationship := range dtst {
		switch relationship.RelationshipType {
		case "is input to", "is the input to":
			_, ok := inputs[relationship.DTID]
			if !ok {
				inputs[relationship.DTID] = cwl.Directory
			} else {
				log.Println("Some kind of error")
			}
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			_, ok := outputs[relationship.DTID]
			if !ok {
				outputs[relationship.DTID] = cwl.Output{
					Type: cwl.Directory,
					// TODO this should be the SSID / the DTID not the STID
					OutputSource: relationship.STID + "/" + relationship.DTID,
				}
			} else {
				log.Println("Some kind of error")
			}
		default:
			log.Printf("Unknown relationship type when converting to CWL (DT-ST): %s", relationship.RelationshipType)
		}
	}

	// steps
	_, sts, sss, err := step.getVertices()
	if err != nil {
		return cwl.Cwl{}, err
	}

	for _, innerStep := range sss {
		stepInputs := make(map[string]string)
		var stepOutputs []string
		runInputs := make(map[string]cwl.IOType)
		runOutputs := make(map[string]cwl.IOType)

		// get the dataset dtst with this ss
		dtss, err := orms.GetDTSSRelationshipsForSS(db, innerStep)
		if err != nil {
			return cwl.Cwl{}, err
		}
		for _, relationship := range dtss {
			datasetSource, err := getDTSource(step, relationship.DTID)
			if err != nil {
				log.Printf("error %s", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if datasetSource != "" {
				stepInput = datasetSource + "/" + relationship.DTID
			}

			// If the dataset of this relationship is in the global outputs make it so that it considers the source
			_, ok := outputs[relationship.DTID]
			if ok {
				outputs[relationship.DTID] = cwl.Output{
					Type:         cwl.Directory,
					OutputSource: stepInput,
				}
			}
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
				runInputs[relationship.DTID] = cwl.Directory
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.SSID+"/"+relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			default:
				log.Printf("Unknown relationship type when converting to CWL (DT-SS): %s", relationship.RelationshipType)
			}
		}

		steps[innerStep] = cwl.Step{
			Run: cwl.Run{
				Class:   "Operation",
				Inputs:  runInputs,
				Outputs: runOutputs,
			},
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	for _, innerStep := range sts {
		stepInputs := make(map[string]string)
		var stepOutputs []string
		runInputs := make(map[string]cwl.IOType)
		runOutputs := make(map[string]cwl.IOType)

		for _, relationship := range dtst {
			datasetSource, err := getDTSource(step, relationship.DTID)
			if err != nil {
				log.Printf("error %s", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if datasetSource != "" {
				stepInput = datasetSource + "/" + relationship.DTID
			}

			// If the dataset of this relationship is in the global outputs make it so that it considers the source
			_, ok := outputs[relationship.DTID]
			if ok {
				outputs[relationship.DTID] = cwl.Output{
					Type:         cwl.Directory,
					OutputSource: stepInput,
				}
			}
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
				runInputs[relationship.DTID] = cwl.Directory
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.STID+"/"+relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			default:
				log.Printf("Unknown relationship type when converting to CWL (DT-SS): %s", relationship.RelationshipType)
			}
		}

		steps[innerStep] = cwl.Step{
			Run: cwl.Run{
				Class:   "Operation",
				Inputs:  runInputs,
				Outputs: runOutputs,
			},
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	return cwl.Cwl{
		CWLVersion: "v1.2",
		Class:      "Workflow",
		Inputs:     inputs,
		Outputs:    outputs,
		Steps:      steps,
	}, nil
}

func getDTSource(step Step, dt string) (string, error) {
	predecessorsMap, err := step.Graph.PredecessorMap()
	if err != nil {
		return "", err
	}

	predecessors, exists := predecessorsMap[dt]
	if !exists || len(predecessors) == 0 {
		return "", nil
	}

	var predecessor string
	for predID := range predecessors {
		predecessor = predID
		break
	}

	if len(predecessors) > 1 {
		predecessorsList := make([]string, len(predecessors))
		for k := range predecessors {
			predecessorsList = append(predecessorsList, k)
		}
		log.Printf("WARNING: %s is generated from multiple SSs %s, choosing one at random (this is something that has to be fixed in the spreadsheet description)", dt, predecessorsList)
	}

	return predecessor, nil
}

func getDTSourceWorkflow(workflow Workflow, dt string) (string, error) {
	predecessorsMap, err := workflow.Graph.PredecessorMap()
	if err != nil {
		return "", err
	}

	predecessors, exists := predecessorsMap[dt]
	if !exists || len(predecessors) == 0 {
		return "", nil
	}

	var predecessor string
	for predID := range predecessors {
		predecessor = predID
		break
	}

	if len(predecessors) > 1 {
		predecessorsList := make([]string, len(predecessors))
		for k := range predecessors {
			predecessorsList = append(predecessorsList, k)
		}
		log.Printf("WARNING: %s is generated from multiple SSs %s, choosing one at random (this is something that has to be fixed in the spreadsheet description)", dt, predecessorsList)
	}

	return predecessor, nil
}
