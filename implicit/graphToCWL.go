package implicit

import (
	"database/sql"
	"dt-geo-db/cwl"
	"dt-geo-db/model"
	"log"
)

// WorkflowToCWL converts a workflow to a CWL description.
func WorkflowToCWL(workflow Workflow, db *sql.DB) (cwl.Cwl, error) {
	cwlInputs := make(map[string]any)
	cwlOutputs := make(map[string]cwl.Output)
	steps := make(map[string]cwl.Step)

	// Get the global input and outputs for this step
	dtst, err := model.GetDTSTRelationshipsForWF(db, workflow.Name)
	if err != nil {
		return cwl.Cwl{}, err
	}

	// inputs and outputs maps store dtIDs that are inputs or outputs.
	inputs, outputs := make(map[string]string), make(map[string]string)
	for _, relationship := range dtst {
		switch relationship.RelationshipType {
		case "is input to", "is the input to", "is input from":
			continue
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			outputs[relationship.DTID] = relationship.DTID
		default:
			log.Printf("Unknown relationship type when converting to CWL (DT-ST): %s", relationship.RelationshipType)
		}
	}

	// inputs are all the datasets that are not output of anything
	dts, err := model.GetDTsForWF(db, workflow.Name)
	if err != nil {
		return cwl.Cwl{}, err
	}
	for _, dt := range dts {
		if _, ok := outputs[dt.ID]; !ok {
			inputs[dt.ID] = dt.ID
		}
	}

	// To handle multiple output sources, we create a temporary map.
	outputSources := make(map[string][]string)
	// For conditionally adding the requirement
	multipleSourcesFound := false

	// for each dataset calculate the source
	for _, dt := range dts {
		dsources, err := getDTSourceWorkflow(workflow, dt.ID)
		if err != nil {
			return cwl.Cwl{}, err
		}
		if len(dsources) == 0 {
			continue
		}

		// For inputs, we continue to use the first available source.
		if _, ok := inputs[dt.ID]; ok {
			inputs[dt.ID] = dsources[0] + "/" + inputs[dt.ID]
		}

		// For outputs, build a list of all sources.
		if _, ok := outputs[dt.ID]; ok {
			sources := []string{}
			for _, src := range dsources {
				sources = append(sources, src+"/"+outputs[dt.ID])
			}
			// If more than one source, set the flag.
			if len(sources) > 1 {
				multipleSourcesFound = true
			}
			outputSources[dt.ID] = sources
		}
	}

	// build the objects for the cwl inputs and outputs
	for dt := range inputs {
		cwlInputs[dt] = cwl.Input{Type: cwl.Directory}
	}
	// Build outputs: if a dt has multiple sources, change its type and add linkMerge.
	for dt, dtValue := range outputs {
		if sources, exists := outputSources[dt]; exists && len(sources) > 1 {
			newType := cwl.IOType(string(cwl.Directory) + "[]")
			cwlOutputs[dt] = cwl.Output{
				Type:         newType,
				OutputSource: []any{},
				LinkMerge:    "merge_flattened",
			}
			tmp := cwlOutputs[dt]
			for _, src := range sources {
				tmp.OutputSource = append(tmp.OutputSource.([]any), src)
			}
			cwlOutputs[dt] = tmp
		} else if sources, exists := outputSources[dt]; exists {
			cwlOutputs[dt] = cwl.Output{
				Type:         cwl.Directory,
				OutputSource: []any{sources[0]},
			}
		} else {
			cwlOutputs[dt] = cwl.Output{
				Type:         cwl.Directory,
				OutputSource: []any{dtValue},
			}
		}
	}

	// get all the nodes in this wf that are not datasets
	sts, err := workflow.getVertices()
	if err != nil {
		return cwl.Cwl{}, err
	}

	// calculate the steps, their inputs and their outputs
	for _, step := range sts {
		stepInputs := make(map[string]string)
		var stepOutputs []string

		relationships, err := model.GetDTSTRelationships(db, step.Id)
		if err != nil {
			return cwl.Cwl{}, err
		}

		for _, relationship := range relationships {
			dsources, err := getDTSourceWorkflow(workflow, relationship.DTID)
			if err != nil {
				log.Printf("error %s", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if len(dsources) > 0 {
				stepInput = dsources[0] + "/" + relationship.DTID
			}

			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.STID+"/"+relationship.DTID)
			default:
				log.Printf("Unknown relationship type when converting to CWL (DT-ST): %s", relationship.RelationshipType)
			}
		}

		if len(stepInputs) == 0 && len(stepOutputs) == 0 {
			log.Printf("WARNING: %s has no inputs and no outputs, are you sure it's correct?", step.Id)
		}

		steps[step.Id] = cwl.Step{
			Run: step.Id + ".cwl",
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	// Build the requirements map: add MultipleInputFeatureRequirement only if needed.
	reqs := map[string]map[string]string{
		"SubworkflowFeatureRequirement": {},
	}
	if multipleSourcesFound {
		reqs["MultipleInputFeatureRequirement"] = map[string]string{}
	}

	return cwl.Cwl{
		CWLVersion:   "v1.2",
		Class:        "Workflow",
		Inputs:       cwlInputs,
		Outputs:      cwlOutputs,
		Requirements: reqs,
		Steps:        steps,
	}, nil
}

// StepToCWL converts a step to a CWL description.
func StepToCWL(step Step, db *sql.DB) (cwl.Cwl, error) {
	inputs := make(map[string]any)
	outputs := make(map[string]cwl.Output)
	steps := make(map[string]cwl.Step)

	// Get the global input and outputs for this step
	dtst, err := model.GetDTSTRelationships(db, step.Id)
	if err != nil {
		return cwl.Cwl{}, err
	}

	// inputs and outputs
	for _, relationship := range dtst {
		switch relationship.RelationshipType {
		case "is input to", "is the input to":
			if _, ok := inputs[relationship.DTID]; !ok {
				inputs[relationship.DTID] = cwl.Directory
			} else {
				log.Println("Some kind of error")
			}
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			// If an output already exists, append the new source.
			if out, ok := outputs[relationship.DTID]; ok {
				// If this is the first time a duplicate is found, convert type to an array.
				if len(out.OutputSource.([]any)) == 1 {
					out.Type = cwl.IOType(string(cwl.Directory) + "[]")
				}
				sources := out.OutputSource.([]any)
				sources = append(sources, relationship.STID+"/"+relationship.DTID)
				out.OutputSource = sources
				out.LinkMerge = "merge_flattened"
				outputs[relationship.DTID] = out
			} else {
				outputs[relationship.DTID] = cwl.Output{
					Type:         cwl.Directory,
					OutputSource: []any{relationship.STID + "/" + relationship.DTID},
				}
			}
		default:
			log.Printf("Unknown relationship type when converting to CWL (DT-ST): %s", relationship.RelationshipType)
		}
	}

	// steps
	_, sts, sss, err := step.getVertices()
	if err != nil {
		return cwl.Cwl{}, err
	}

	for _, innerStep := range sss {
		stepInputs := make(map[string]string)
		var stepOutputs []string
		runInputs := make(map[string]cwl.IOType)
		runOutputs := make(map[string]cwl.IOType)

		// get the dataset relationships with this inner step
		dtss, err := model.GetDTSSRelationshipsForSS(db, innerStep)
		if err != nil {
			return cwl.Cwl{}, err
		}
		for _, relationship := range dtss {
			dsources, err := getDTSource(step, relationship.DTID)
			if err != nil {
				log.Printf("error %s", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if len(dsources) > 0 {
				stepInput = dsources[0] + "/" + relationship.DTID
			}

			// If the dataset of this relationship is in the global outputs, update its source.
			if _, ok := outputs[relationship.DTID]; ok {
				out := cwl.Output{
					Type:         cwl.Directory,
					OutputSource: []any{stepInput},
				}
				outputs[relationship.DTID] = out
			}
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
				runInputs[relationship.DTID] = cwl.Directory
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			default:
				log.Printf("Unknown relationship type when converting to CWL (DT-SS): %s", relationship.RelationshipType)
			}
		}

		if len(stepInputs) == 0 && len(stepOutputs) == 0 {
			log.Printf("WARNING: %s has no inputs and no outputs, are you sure it's correct?", step.Id)
		}

		steps[innerStep] = cwl.Step{
			Run: cwl.Run{
				Class:   "Operation",
				Inputs:  runInputs,
				Outputs: runOutputs,
			},
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	for _, innerStep := range sts {
		stepInputs := make(map[string]string)
		var stepOutputs []string
		runInputs := make(map[string]cwl.IOType)
		runOutputs := make(map[string]cwl.IOType)

		for _, relationship := range dtst {
			dsources, err := getDTSource(step, relationship.DTID)
			if err != nil {
				log.Printf("error %s", err)
				return cwl.Cwl{}, err
			}
			stepInput := relationship.DTID
			if len(dsources) > 0 {
				stepInput = dsources[0] + "/" + relationship.DTID
			}

			// If the dataset of this relationship is in the global outputs, update its source.
			if _, ok := outputs[relationship.DTID]; ok {
				out := cwl.Output{
					Type:         cwl.Directory,
					OutputSource: []any{stepInput},
				}
				outputs[relationship.DTID] = out
			}
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				stepInputs[relationship.DTID] = stepInput
				runInputs[relationship.DTID] = cwl.Directory
			case "is output to", "is the output from", "is generated by", "is output from":
				stepOutputs = append(stepOutputs, relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			case "is updated by":
				stepOutputs = append(stepOutputs, relationship.STID+"/"+relationship.DTID)
				runOutputs[relationship.DTID] = cwl.Directory
			default:
				log.Printf("Unknown relationship type when converting to CWL (DT-SS): %s", relationship.RelationshipType)
			}
		}

		steps[innerStep] = cwl.Step{
			Run: cwl.Run{
				Class:   "Operation",
				Inputs:  runInputs,
				Outputs: runOutputs,
			},
			In:  stepInputs,
			Out: stepOutputs,
		}
	}

	return cwl.Cwl{
		CWLVersion: "v1.2",
		Class:      "Workflow",
		Inputs:     inputs,
		Outputs:    outputs,
		Steps:      steps,
	}, nil
}

// getDTSource returns all the sources that generate the given dataset in a step.
func getDTSource(step Step, dt string) ([]string, error) {
	predecessorsMap, err := step.Graph.PredecessorMap()
	if err != nil {
		return nil, err
	}

	predecessors, exists := predecessorsMap[dt]
	if !exists || len(predecessors) == 0 {
		return nil, nil
	}

	sources := []string{}
	for predID := range predecessors {
		sources = append(sources, predID)
	}

	// if len(sources) > 1 {
	// 	log.Printf("WARNING: %s is generated from multiple SSs %v, using all sources", dt, sources)
	// }

	return sources, nil
}

// getDTSourceWorkflow returns all the sources that generate the given dataset in a workflow.
func getDTSourceWorkflow(workflow Workflow, dt string) ([]string, error) {
	predecessorsMap, err := workflow.Graph.PredecessorMap()
	if err != nil {
		return nil, err
	}

	predecessors, exists := predecessorsMap[dt]
	if !exists || len(predecessors) == 0 {
		return nil, nil
	}

	sources := []string{}
	for predID := range predecessors {
		sources = append(sources, predID)
	}

	// if len(sources) > 1 {
	// 	log.Printf("WARNING: %s is generated from multiple STs %v, using all sources", dt, sources)
	// 	adjacencyMap, err := workflow.Graph.AdjacencyMap()
	// 	if err == nil && len(adjacencyMap[dt]) > 0 {
	// 		successorsList := []string{}
	// 		for k := range adjacencyMap[dt] {
	// 			successorsList = append(successorsList, k)
	// 		}
	// 		log.Printf("Successors: %v", successorsList)
	// 	}
	// }

	return sources, nil
}
