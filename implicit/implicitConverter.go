package implicit

import (
	"database/sql"
	"dt-geo-db/orms"
	"github.com/dominikbraun/graph"
	"github.com/dominikbraun/graph/draw"
	"log"
	"os"
	"strings"
)

// Workflow represents the complete workflow, its graph is the structure of the workflow, with each node being a Step
type Workflow struct {
	Name  string
	Graph graph.Graph[string, Step]
}

// Step represents a step, represented through a graph.
// If the step is manual the graph will be empty
// If the step is automatic, the graph will have a node for each SS execution inside the step
type Step struct {
	Id    string
	Graph graph.Graph[string, string]
}

func stepHash(st Step) string {
	return st.Id
}

func GetWorkflowGraph(wf string, db *sql.DB) (Workflow, error) {
	g := graph.New(stepHash, graph.Directed(), graph.PreventCycles())

	steps, err := orms.GetSTsForWF(db, wf)
	if err != nil {
		return Workflow{}, err
	}

	// for each step calculate its graph using the dependencies
	for _, step := range steps {
		sg, err := generateStepGraph(step, db)
		if err != nil {
			log.Printf("Error generating graph for step: %s", step.ID)
		}
		err = g.AddVertex(sg, graph.VertexAttribute("colorscheme", "ylorbr3"), graph.VertexAttribute("style", "filled"), graph.VertexAttribute("color", "2"), graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			log.Printf("Error adding node %s to main graph", step.ID)
		}
	}

	// add the datasets to the graph
	dts, err := orms.GetDTsForWF(db, wf)
	if err != nil {
		return Workflow{}, err
	}

	for _, dt := range dts {
		err := g.AddVertex(Step{
			Id:    dt.ID,
			Graph: nil,
		}, graph.VertexAttribute("colorscheme", "blues3"), graph.VertexAttribute("style", "filled"), graph.VertexAttribute("color", "2"), graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			log.Printf("Error adding node %s to main graph", dt.ID)
		}
	}

	// calculate the edges
	for _, step := range steps {
		dtst, err := orms.GetDTSTRelationships(db, step.ID)
		if err != nil {
			return Workflow{}, err
		}

		for _, relationship := range dtst {
			//err := g.AddVertex(relationship.DTID, graph.VertexAttribute("colorscheme", "blues3"), graph.VertexAttribute("style", "filled"), graph.VertexAttribute("color", "2"), graph.VertexAttribute("fillcolor", "1"))
			//if err != nil {
			//	log.Printf("Error adding node %s to %s subgraph", relationship.DTID, step)
			//}

			s := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.STID
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				err = g.AddEdge(relationship.DTID, relationship.STID, graph.EdgeAttribute("label", relationship.RelationshipType), graph.EdgeAttribute("labeltooltip", s))
				if err != nil {
					log.Printf("WARNING: error adding edge '%s' -> '%s' in main graph: %v", relationship.DTID, relationship.STID, err)
				}
			case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
				err = g.AddEdge(relationship.STID, relationship.DTID, graph.EdgeAttribute("label", relationship.RelationshipType), graph.EdgeAttribute("labeltooltip", s))
				if err != nil {
					log.Printf("WARNING: error adding edge '%s' -> '%s' in main graph: %v", relationship.STID, relationship.DTID, err)
				}
			default:
				log.Printf("Unknown relationship type: %s", relationship.RelationshipType)
			}
		}
	}

	return Workflow{
		wf,
		g,
	}, nil
}

// Generate the graph for a step
func generateStepGraph(step orms.ST, db *sql.DB) (Step, error) {
	g := graph.New(graph.StringHash, graph.Directed(), graph.PreventCycles())

	// Get all the SS for this ST
	sss, err := orms.GetSSForST(db, step.ID)
	if err != nil {
		return Step{}, err
	}
	for _, ss := range sss {
		// add all the ss as nodes in the graph
		err := g.AddVertex(ss.ID, graph.VertexAttribute("colorscheme", "ylorbr3"), graph.VertexAttribute("style", "filled"), graph.VertexAttribute("color", "2"), graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			log.Printf("Error adding node %s to %s subgraph", ss.ID, step)
		}
	}

	// get all the datasets used in this step
	dts, err := orms.GetDTsRelatedToSTviaSSs(db, step.ID)
	if err != nil {
		return Step{}, err
	}
	for _, dt := range dts {
		// add all the dts as nodes in the graph
		err := g.AddVertex(dt.ID, graph.VertexAttribute("colorscheme", "blues3"), graph.VertexAttribute("style", "filled"), graph.VertexAttribute("color", "2"), graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			log.Printf("Error adding node %s to %s subgraph", dt.ID, step)
		}
	}

	//get all the dt-ss relationships for this step
	relationships, err := orms.GetDTSSRelationshipsForST(db, step.ID)
	if err != nil {
		return Step{}, err
	}

	// If the step is a manual step (it doesn't have any ss)
	if len(relationships) == 0 {
		err := g.AddVertex(step.ID, graph.VertexAttribute("colorscheme", "greens3"), graph.VertexAttribute("style", "filled"), graph.VertexAttribute("color", "2"), graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			log.Printf("Error adding node %s to %s subgraph", step.ID, step)
		}
		dtst, err := orms.GetDTSTRelationships(db, step.ID)
		if err != nil {
			return Step{}, err
		}
		for _, relationship := range dtst {
			err := g.AddVertex(relationship.DTID, graph.VertexAttribute("colorscheme", "blues3"), graph.VertexAttribute("style", "filled"), graph.VertexAttribute("color", "2"), graph.VertexAttribute("fillcolor", "1"))
			if err != nil {
				log.Printf("Error adding node %s to %s subgraph", relationship.DTID, step)
			}

			s := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.STID
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				err = g.AddEdge(relationship.DTID, relationship.STID, graph.EdgeAttribute("label", relationship.RelationshipType), graph.EdgeAttribute("labeltooltip", s))
				if err != nil {
					log.Printf("WARNING: error adding edge '%s' -> '%s' in subgraph %s: %v", relationship.DTID, relationship.STID, step.ID, err)
				}
			case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
				err = g.AddEdge(relationship.STID, relationship.DTID, graph.EdgeAttribute("label", relationship.RelationshipType), graph.EdgeAttribute("labeltooltip", s))
				if err != nil {
					log.Printf("WARNING: error adding edge '%s' -> '%s' in subgraph %s: %v", relationship.STID, relationship.DTID, step.ID, err)
				}
			default:
				log.Printf("Unknown relationship type: %s", relationship.RelationshipType)
			}
		}
	}

	for _, relationship := range relationships {
		s := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.SSID
		switch relationship.RelationshipType {
		case "is input to", "is the input to", "is input from":
			err := g.AddEdge(relationship.DTID, relationship.SSID, graph.EdgeAttribute("label", relationship.RelationshipType), graph.EdgeAttribute("labeltooltip", s))
			if err != nil {
				log.Printf("WARNING: error adding edge '%s' -> '%s' in subgraph %s: %v", relationship.DTID, relationship.SSID, step.ID, err)
			}
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			err := g.AddEdge(relationship.SSID, relationship.DTID, graph.EdgeAttribute("label", relationship.RelationshipType), graph.EdgeAttribute("labeltooltip", s))
			if err != nil {
				log.Printf("WARNING: error adding edge '%s' -> '%s' in subgraph %s: %v", relationship.SSID, relationship.DTID, step.ID, err)
			}
		default:
			log.Printf("Unknown relationship type: %s", relationship.RelationshipType)
		}

	}

	return Step{
		Id:    step.ID,
		Graph: g,
	}, nil
}

func (w *Workflow) SaveToFile(db *sql.DB) error {
	vertices, err := w.getVertices()
	if err != nil {
		return err
	}

	path := "workflows/implicit/" + w.Name + "/"
	for _, vertex := range vertices {
		if vertex.Graph == nil {
			continue
		}
		err = os.MkdirAll(path, os.ModePerm)
		if err != nil {
			log.Printf("Error creating directory")
			return err
		}

		file, err := os.Create(path + vertex.Id + ".dot")
		if err != nil {
			log.Printf("Error creating file")
			return err
		}

		err = draw.DOT(vertex.Graph, file)
		if err != nil {
			log.Printf("Error saving dot to file")
			return err
		}
		file.Close()

		cwl, err := StepToCWL(vertex, db)
		if err != nil {
			log.Printf("Error saving dot to file")
			return err
		}
		err = cwl.SaveToFile(path + vertex.Id + ".cwl")
		if err != nil {
			log.Printf("Error saving dot to file")
			return err
		}
	}

	file, err := os.Create(path + "steps.dot")
	if err != nil {
		log.Printf("Error creating file")
		return err
	}
	defer file.Close()

	err = draw.DOT(w.Graph, file)
	if err != nil {
		log.Printf("Error saving dot to file: %s", err)
		return err
	}

	cwl, err := WorkflowToCWL(*w, db)
	if err != nil {
		log.Printf("Error saving dot to file")
		return err
	}
	err = cwl.SaveToFile(path + w.Name + ".cwl")
	if err != nil {
		log.Printf("Error saving dot to file")
		return err
	}

	return nil
}

func (w *Workflow) getVertices() ([]Step, error) {
	adjMap, err := w.Graph.AdjacencyMap()
	if err != nil {
		return nil, err
	}

	vertices := make([]Step, 0, len(adjMap))
	for hash := range adjMap {
		vertex, err := w.Graph.Vertex(hash)
		if err != nil {
			return nil, err
		}
		// If it is a DT skip it
		if vertex.Graph == nil {
			continue
		}
		vertices = append(vertices, vertex)
	}
	return vertices, nil
}

func (s *Step) getVertices() (dts []string, sts []string, sss []string, err error) {
	adjMap, err := s.Graph.AdjacencyMap()
	if err != nil {
		return nil, nil, nil, err
	}

	dts = make([]string, 0, len(adjMap))
	sts = make([]string, 0, len(adjMap))
	sss = make([]string, 0, len(adjMap))
	for hash := range adjMap {
		vertex, err := s.Graph.Vertex(hash)
		if err != nil {
			return nil, nil, nil, err
		}

		if strings.Contains(vertex, "DT") {
			dts = append(dts, vertex)
		}
		if strings.Contains(vertex, "ST") {
			sts = append(sts, vertex)
		}
		if strings.Contains(vertex, "SS") {
			sss = append(sss, vertex)
		}
	}
	return dts, sts, sss, nil
}
