package implicit

import (
	"database/sql"
	"dt-geo-db/logger"
	"dt-geo-db/model"
	"dt-geo-db/rocrate"
	"os"
	"strings"

	"github.com/dominikbraun/graph"
	"github.com/dominikbraun/graph/draw"
)

// Workflow represents the complete workflow; its graph is the structure of the workflow, with each node being a Step.
type Workflow struct {
	Name  string
	Graph graph.Graph[string, Step]
}

// Step represents a step, represented through a graph.
// If the step is manual the graph will be empty.
// If the step is automatic, the graph will have a node for each SS execution inside the step.
type Step struct {
	Id    string
	Graph graph.Graph[string, string]
}

func stepHash(st Step) string {
	return st.Id
}

func GetWorkflowGraph(wf string, db *sql.DB) (Workflow, error) {
	logger.Debug("Creating main workflow graph for", wf)
	g := graph.New(stepHash, graph.Directed(), graph.PreventCycles())

	steps, err := model.GetSTsForWF(db, wf)
	if err != nil {
		logger.Error("Error retrieving steps for workflow", wf, ":", err)
		return Workflow{}, err
	}

	// For each step, calculate its graph using the dependencies.
	for _, step := range steps {
		sg, err := generateStepGraph(step, db)
		if err != nil {
			logger.Error("Error generating subgraph for step", step.ID, ":", err)
		}
		err = g.AddVertex(sg,
			graph.VertexAttribute("colorscheme", "ylorbr3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			logger.Error("Error adding step node", step.ID, "to main graph:", err)
		} else {
			logger.Debug("Added step node", step.ID, "to main graph")
		}
	}

	// Add the dataset nodes to the graph.
	dts, err := model.GetDTsForWF(db, wf)
	if err != nil {
		logger.Error("Error retrieving datasets for workflow", wf, ":", err)
		return Workflow{}, err
	}

	for _, dt := range dts {
		err := g.AddVertex(Step{
			Id:    dt.ID,
			Graph: nil,
		},
			graph.VertexAttribute("colorscheme", "blues3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			logger.Error("Error adding dataset node", dt.ID, "to main graph:", err)
		} else {
			logger.Debug("Added dataset node", dt.ID, "to main graph")
		}
	}

	// Calculate the edges.
	for _, step := range steps {
		dtst, err := model.GetDTSTRelationships(db, step.ID)
		if err != nil {
			logger.Error("Error retrieving DT-ST relationships for step", step.ID, ":", err)
			return Workflow{}, err
		}

		for _, relationship := range dtst {
			s := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.STID
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				err = g.AddEdge(relationship.DTID, relationship.STID,
					graph.EdgeAttribute("label", relationship.RelationshipType),
					graph.EdgeAttribute("labeltooltip", s))
				if err != nil {
					logger.Error("Error adding edge", relationship.DTID, "->", relationship.STID, "in main graph:", err)
				} else {
					logger.Debug("Added edge", relationship.DTID, "->", relationship.STID, "in main graph")
				}
			case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
				err = g.AddEdge(relationship.STID, relationship.DTID,
					graph.EdgeAttribute("label", relationship.RelationshipType),
					graph.EdgeAttribute("labeltooltip", s))
				if err != nil {
					logger.Error("Error adding edge", relationship.STID, "->", relationship.DTID, "in main graph:", err)
				} else {
					logger.Debug("Added edge", relationship.STID, "->", relationship.DTID, "in main graph")
				}
			default:
				logger.Error("Unknown DT_ST relationship type:", relationship.RelationshipType)
			}
		}
	}

	logger.Info("Main workflow graph created successfully for", wf)
	return Workflow{
		Name:  wf,
		Graph: g,
	}, nil
}

// generateStepGraph generates the subgraph for a step.
func generateStepGraph(step model.ST, db *sql.DB) (Step, error) {
	logger.Debug("Generating subgraph for step", step.ID)
	g := graph.New(graph.StringHash, graph.Directed(), graph.PreventCycles())

	// Get all the SS for this ST.
	sss, err := model.GetSSForST(db, step.ID)
	if err != nil {
		logger.Error("Failed to retrieve SS for step", step.ID, ":", err)
		return Step{}, err
	}
	for _, ss := range sss {
		err := g.AddVertex(ss.ID,
			graph.VertexAttribute("colorscheme", "ylorbr3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			logger.Error("Error adding SS node", ss.ID, "to subgraph for step", step.ID, ":", err)
		} else {
			logger.Debug("Added SS node", ss.ID, "to subgraph for step", step.ID)
		}
	}

	// Get all the datasets used in this step.
	dts, err := model.GetDTsRelatedToSTviaSSs(db, step.ID)
	if err != nil {
		logger.Error("Failed to retrieve DTs for step", step.ID, ":", err)
		return Step{}, err
	}
	for _, dt := range dts {
		err := g.AddVertex(dt.ID,
			graph.VertexAttribute("colorscheme", "blues3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			logger.Error("Error adding dataset node", dt.ID, "to subgraph for step", step.ID, ":", err)
		} else {
			logger.Debug("Added dataset node", dt.ID, "to subgraph for step", step.ID)
		}
	}

	// Get all the DT-SS relationships for this step.
	relationships, err := model.GetDTSSRelationshipsForST(db, step.ID)
	if err != nil {
		logger.Error("Failed to retrieve DT-SS relationships for step", step.ID, ":", err)
		return Step{}, err
	}

	// If the step is manual (no SS relationships exist), add the step itself as a vertex.
	if len(relationships) == 0 {
		err := g.AddVertex(step.ID,
			graph.VertexAttribute("colorscheme", "greens3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			logger.Error("Error adding manual step node", step.ID, "to subgraph:", err)
		} else {
			logger.Debug("Added manual step node", step.ID, "to subgraph")
		}
		dtst, err := model.GetDTSTRelationships(db, step.ID)
		if err != nil {
			logger.Error("Failed to retrieve DT-ST relationships for manual step", step.ID, ":", err)
			return Step{}, err
		}
		for _, relationship := range dtst {
			err := g.AddVertex(relationship.DTID,
				graph.VertexAttribute("colorscheme", "blues3"),
				graph.VertexAttribute("style", "filled"),
				graph.VertexAttribute("color", "2"),
				graph.VertexAttribute("fillcolor", "1"))
			if err != nil {
				logger.Error("Error adding dataset node", relationship.DTID, "to manual step subgraph", step.ID, ":", err)
			}
			s := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.STID
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				err = g.AddEdge(relationship.DTID, relationship.STID,
					graph.EdgeAttribute("label", relationship.RelationshipType),
					graph.EdgeAttribute("labeltooltip", s))
				if err != nil {
					logger.Error("Error adding edge", relationship.DTID, "->", relationship.STID, "in manual step subgraph", step.ID, ":", err)
				}
			case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
				err = g.AddEdge(relationship.STID, relationship.DTID,
					graph.EdgeAttribute("label", relationship.RelationshipType),
					graph.EdgeAttribute("labeltooltip", s))
				if err != nil {
					logger.Error("Error adding edge", relationship.STID, "->", relationship.DTID, "in manual step subgraph", step.ID, ":", err)
				}
			default:
				logger.Error("Unknown DT_ST relationship type:", relationship.RelationshipType)
			}
		}
	}

	// Process DT-SS relationships for non-manual steps.
	for _, relationship := range relationships {
		s := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.SSID
		switch relationship.RelationshipType {
		case "is input to", "is the input to", "is input from":
			err := g.AddEdge(relationship.DTID, relationship.SSID,
				graph.EdgeAttribute("label", relationship.RelationshipType),
				graph.EdgeAttribute("labeltooltip", s))
			if err != nil {
				logger.Error("Error adding edge", relationship.DTID, "->", relationship.SSID, "in subgraph", step.ID, ":", err)
			} else {
				logger.Debug("Added edge", relationship.DTID, "->", relationship.SSID, "in subgraph", step.ID)
			}
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			err := g.AddEdge(relationship.SSID, relationship.DTID,
				graph.EdgeAttribute("label", relationship.RelationshipType),
				graph.EdgeAttribute("labeltooltip", s))
			if err != nil {
				logger.Error("Error adding edge", relationship.SSID, "->", relationship.DTID, "in subgraph", step.ID, ":", err)
			} else {
				logger.Debug("Added edge", relationship.SSID, "->", relationship.DTID, "in subgraph", step.ID)
			}
		default:
			logger.Error("Unknown SS_DT relationship type:", relationship.RelationshipType)
		}
	}

	logger.Debug("Subgraph generated for step", step.ID)
	return Step{
		Id:    step.ID,
		Graph: g,
	}, nil
}

func (w *Workflow) SaveToFile(db *sql.DB) error {
	vertices, err := w.getVertices()
	if err != nil {
		logger.Error("Error retrieving vertices for workflow", w.Name, ":", err)
		return err
	}

	path := "workflows/" + w.Name + "/"
	for _, vertex := range vertices {
		if vertex.Graph == nil {
			logger.Debug("Skipping vertex", vertex.Id, "as it has no graph")
			continue
		}
		err = os.MkdirAll(path, os.ModePerm)
		if err != nil {
			logger.Error("Error creating directory", path, ":", err)
			return err
		}

		file, err := os.Create(path + vertex.Id + ".dot")
		if err != nil {
			logger.Error("Error creating file", path+vertex.Id+".dot", ":", err)
			return err
		}

		err = draw.DOT(vertex.Graph, file)
		if err != nil {
			logger.Error("Error saving DOT to file", path+vertex.Id+".dot", ":", err)
			return err
		}
		file.Close()
		logger.Debug("Saved DOT file for vertex", vertex.Id)

		cwlObj, err := StepToCWL(vertex, db)
		if err != nil {
			logger.Error("Error converting step", vertex.Id, "to CWL:", err)
			return err
		}
		err = cwlObj.SaveToFile(path + vertex.Id + ".cwl")
		if err != nil {
			logger.Error("Error saving CWL file for vertex", vertex.Id, ":", err)
			return err
		}
		logger.Debug("Saved CWL file for vertex", vertex.Id)
	}

	file, err := os.Create(path + "steps.dot")
	if err != nil {
		logger.Error("Error creating file", path+"steps.dot", ":", err)
		return err
	}
	defer file.Close()

	err = draw.DOT(w.Graph, file)
	if err != nil {
		logger.Error("Error saving DOT for steps:", err)
		return err
	}

	cwlObj, err := WorkflowToCWL(*w, db)
	if err != nil {
		logger.Error("Error converting workflow", w.Name, "to CWL:", err)
		return err
	}
	err = cwlObj.SaveToFile(path + w.Name + ".cwl")
	if err != nil {
		logger.Error("Error saving workflow CWL file", path+w.Name+".cwl", ":", err)
		return err
	}
	logger.Debug("Saved workflow CWL file", path+w.Name+".cwl")

	crate, err := rocrate.WorkflowToRoCrate(w.Name, cwlObj, db)
	if err != nil {
		logger.Error("Error generating RO-Crate for workflow", w.Name, ":", err)
		return err
	}
	err = crate.SaveToFile(path + "ro-crate-metadata.json")
	if err != nil {
		logger.Error("Error saving RO-Crate metadata file", path+"ro-crate-metadata.json", ":", err)
		return err
	}
	logger.Debug("Saved RO-Crate metadata file", path+"ro-crate-metadata.json")

	return nil
}

func (w *Workflow) getVertices() ([]Step, error) {
	adjMap, err := w.Graph.AdjacencyMap()
	if err != nil {
		logger.Error("Error retrieving adjacency map for workflow", w.Name, ":", err)
		return nil, err
	}

	vertices := make([]Step, 0, len(adjMap))
	for hash := range adjMap {
		vertex, err := w.Graph.Vertex(hash)
		if err != nil {
			logger.Error("Error retrieving vertex", hash, ":", err)
			continue
		}
		// If it is a dataset (DT), skip it.
		if vertex.Graph == nil {
			logger.Debug("Skipping dataset vertex", hash)
			continue
		}
		vertices = append(vertices, vertex)
	}
	logger.Debug("Collected", len(vertices), "vertices for workflow", w.Name)
	return vertices, nil
}

func (s *Step) getVertices() (dts []string, sts []string, sss []string, err error) {
	adjMap, err := s.Graph.AdjacencyMap()
	if err != nil {
		logger.Error("Error retrieving adjacency map for step", s.Id, ":", err)
		return nil, nil, nil, err
	}

	dts = make([]string, 0, len(adjMap))
	sts = make([]string, 0, len(adjMap))
	sss = make([]string, 0, len(adjMap))
	for hash := range adjMap {
		vertex, err := s.Graph.Vertex(hash)
		if err != nil {
			logger.Error("Error retrieving vertex", hash, "for step", s.Id, ":", err)
			continue
		}

		if strings.Contains(vertex, "DT") {
			dts = append(dts, vertex)
		}
		if strings.Contains(vertex, "ST") {
			sts = append(sts, vertex)
		}
		if strings.Contains(vertex, "SS") {
			sss = append(sss, vertex)
		}
	}
	logger.Debug("Step", s.Id, "has", len(dts), "DTs,", len(sts), "STs and", len(sss), "SSs")
	return dts, sts, sss, nil
}
