package implicit

import (
	"database/sql"
	"dt-geo-db/orms"
	"github.com/dominikbraun/graph"
	"github.com/dominikbraun/graph/draw"
	"log"
	"os"
)

// Workflow represents the complete workflow, its graph is the structure of the workflow, with each node being a Step
type Workflow struct {
	Name  string
	Graph graph.Graph[string, Step]
}

// Step represents a step, represented through a graph.
// If the step is manual the graph will be empty
// If the step is automatic, the graph will have a node for each SS execution inside the step
type Step struct {
	Id    string
	Graph graph.Graph[string, string]
}

func stepHash(st Step) string {
	return st.Id
}

func GetWorkflowGraph(wf string, db *sql.DB) (Workflow, error) {
	g := graph.New(stepHash, graph.Directed(), graph.PreventCycles())

	steps, err := orms.GetSTsForWF(db, wf)
	if err != nil {
		return Workflow{}, err
	}

	// for each step calculate its graph using the dependencies
	for _, step := range steps {
		sg, err := generateStepGraph(step, db)
		if err != nil {
			log.Printf("Error generating graph for step: %s", step.ID)
		}
		err = g.AddVertex(sg)
		if err != nil {
			log.Printf("Error adding node %s to main graph", step.ID)
		}
	}

	return Workflow{
		wf,
		g,
	}, nil
}

// Generate the graph for a step
func generateStepGraph(step orms.ST, db *sql.DB) (Step, error) {
	g := graph.New(graph.StringHash, graph.Directed(), graph.PreventCycles())

	// Get all the SS for this ST
	sss, err := orms.GetSSForST(db, step.ID)
	if err != nil {
		return Step{}, err
	}
	for _, ss := range sss {
		// add all the ss as nodes in the graph
		err := g.AddVertex(ss.ID, graph.VertexAttribute("colorscheme", "ylorbr3"), graph.VertexAttribute("style", "filled"), graph.VertexAttribute("color", "2"), graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			log.Printf("Error adding node %s to %s subgraph", ss.ID, step)
		}
	}

	// get all the datasets used in this step
	dts, err := orms.GetDTsRelatedToSTviaSSs(db, step.ID)
	if err != nil {
		return Step{}, err
	}
	for _, dt := range dts {
		// add all the dts as nodes in the graph
		err := g.AddVertex(dt.ID, graph.VertexAttribute("colorscheme", "blues3"), graph.VertexAttribute("style", "filled"), graph.VertexAttribute("color", "2"), graph.VertexAttribute("fillcolor", "1"))
		if err != nil {
			log.Printf("Error adding node %s to %s subgraph", dt.ID, step)
		}
	}

	//get all the dt-ss relationships for this step
	relationships, err := orms.GetDTSSRelationshipsForST(db, step.ID)
	if err != nil {
		return Step{}, err
	}
	for _, relationship := range relationships {
		s := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.SSID
		switch relationship.RelationshipType {
		case "is input to", "is the input to":
			err := g.AddEdge(relationship.DTID, relationship.SSID, graph.EdgeAttribute("label", relationship.RelationshipType), graph.EdgeAttribute("labeltooltip", s))
			if err != nil {
				log.Printf("Warning: error adding edge '%s' -> '%s' in subgraph %s: %v", relationship.DTID, relationship.SSID, step.ID, err)
			}
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from", "is input from":
			err := g.AddEdge(relationship.SSID, relationship.DTID, graph.EdgeAttribute("label", relationship.RelationshipType), graph.EdgeAttribute("labeltooltip", s))
			if err != nil {
				log.Printf("Warning: error adding edge '%s' -> '%s' in subgraph %s: %v", relationship.SSID, relationship.DTID, step.ID, err)
			}
		default:
			log.Printf("Unknown relationship type: %s", relationship.RelationshipType)
		}

	}

	return Step{
		Id:    step.ID,
		Graph: g,
	}, nil
}

func (w *Workflow) SaveToFile(db *sql.DB) error {
	vertices, err := w.getVertices()
	if err != nil {
		return err
	}

	path := "workflows/implicit/" + w.Name + "/"
	for _, vertex := range vertices {
		err = os.MkdirAll(path, os.ModePerm)
		if err != nil {
			log.Printf("Error creating directory")
		}

		file, err := os.Create(path + vertex.Id + ".dot")
		if err != nil {
			log.Printf("Error creating file")
		}

		err = draw.DOT(vertex.Graph, file)
		if err != nil {
			log.Printf("Error saving dot to file")
		}
		file.Close()

		cwl, err := StepToCWL(vertex, db)
		if err != nil {
			log.Printf("Error saving dot to file")
		}
		err = cwl.SaveToFile(path + vertex.Id + ".cwl")
		if err != nil {
			log.Printf("Error saving dot to file")
		}
	}

	file, err := os.Create(path + "steps.dot")
	if err != nil {
		log.Printf("Error creating file")
	}
	defer file.Close()

	err = draw.DOT(w.Graph, file)
	if err != nil {
		log.Printf("Error saving dot to file: %s", err)
	}

	return nil
}

func (w *Workflow) getVertices() ([]Step, error) {
	adjMap, err := w.Graph.AdjacencyMap()
	if err != nil {
		return nil, err
	}

	vertices := make([]Step, 0, len(adjMap))
	for hash := range adjMap {
		vertex, err := w.Graph.Vertex(hash)
		if err != nil {
			return nil, err
		}
		vertices = append(vertices, vertex)
	}
	return vertices, nil
}

func (s *Step) getVertices() ([]string, error) {
	adjMap, err := s.Graph.AdjacencyMap()
	if err != nil {
		return nil, err
	}

	vertices := make([]string, 0, len(adjMap))
	for hash := range adjMap {
		vertex, err := s.Graph.Vertex(hash)
		if err != nil {
			return nil, err
		}
		vertices = append(vertices, vertex)
	}
	return vertices, nil
}
