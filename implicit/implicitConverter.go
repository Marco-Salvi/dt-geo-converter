package implicit

import (
	"database/sql"
	"dt-geo-converter/logger"
	"dt-geo-converter/model"
	"dt-geo-converter/rocrate"
	"os"
	"strings"

	"github.com/dominikbraun/graph"
	"github.com/dominikbraun/graph/draw"
)

// Workflow represents the complete workflow; its graph is the structure of the workflow, with each node being a Step.
type Workflow struct {
	Name  string
	Graph graph.Graph[string, Step]
}

// Step represents a workflow step; its graph is used to represent subcomponents (SS or datasets).
type Step struct {
	Id    string
	Graph graph.Graph[string, string]
}

func stepHash(st Step) string {
	return st.Id
}

// GetWorkflowGraph creates the main workflow graph using steps and dataset nodes.
func GetWorkflowGraph(wf string, db *sql.DB) (Workflow, error) {
	logger.Debug("Creating main workflow graph for", wf)
	g := graph.New(stepHash, graph.Directed(), graph.PreventCycles())

	steps, err := model.GetSTsForWF(db, wf)
	if err != nil {
		logger.Error("Failed to retrieve steps for workflow", wf, ":", err)
		return Workflow{}, err
	}

	// Add each step's subgraph to the main graph.
	for _, step := range steps {
		sg, err := generateStepGraph(step, db)
		if err != nil {
			logger.Error("Failed to generate subgraph for step", step.ID, ":", err)
		}
		if err = g.AddVertex(sg,
			graph.VertexAttribute("colorscheme", "ylorbr3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1")); err != nil {
			logger.Error("Failed to add step node", step.ID, "to main graph:", err)
		} else {
			logger.Debug("Added step node", step.ID, "to main graph")
		}
	}

	// Add dataset nodes.
	dts, err := model.GetDTsForWF(db, wf)
	if err != nil {
		logger.Error("Failed to retrieve datasets for workflow", wf, ":", err)
		return Workflow{}, err
	}
	for _, dt := range dts {
		if err = g.AddVertex(Step{
			Id:    dt.ID,
			Graph: nil,
		},
			graph.VertexAttribute("colorscheme", "blues3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1")); err != nil {
			logger.Error("Failed to add dataset node", dt.ID, "to main graph:", err)
		} else {
			logger.Debug("Added dataset node", dt.ID, "to main graph")
		}
	}

	// Add edges based on DT-ST relationships.
	for _, step := range steps {
		dtst, err := model.GetDTSTRelationships(db, step.ID)
		if err != nil {
			logger.Error("Failed to retrieve DT-ST relationships for step", step.ID, ":", err)
			return Workflow{}, err
		}

		for _, relationship := range dtst {
			labelText := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.STID
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				err = g.AddEdge(relationship.DTID, relationship.STID,
					graph.EdgeAttribute("label", relationship.RelationshipType),
					graph.EdgeAttribute("labeltooltip", labelText))
				if err != nil {
					logger.Warning("Failed to add edge", relationship.DTID, "->", relationship.STID, ":", err)
				} else {
					logger.Debug("Added edge", relationship.DTID, "->", relationship.STID)
				}
			case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
				err = g.AddEdge(relationship.STID, relationship.DTID,
					graph.EdgeAttribute("label", relationship.RelationshipType),
					graph.EdgeAttribute("labeltooltip", labelText))
				if err != nil {
					logger.Warning("Failed to add edge", relationship.STID, "->", relationship.DTID, ":", err)
				} else {
					logger.Debug("Added edge", relationship.STID, "->", relationship.DTID)
				}
			default:
				logger.Warning("Unknown DT_ST relationship type:", relationship.RelationshipType)
			}
		}
	}

	logger.Debug("Main workflow graph created successfully for", wf)
	return Workflow{
		Name:  wf,
		Graph: g,
	}, nil
}

// generateStepGraph creates the subgraph for a given step.
func generateStepGraph(step model.ST, db *sql.DB) (Step, error) {
	logger.Debug("Generating subgraph for step", step.ID)
	g := graph.New(graph.StringHash, graph.Directed(), graph.PreventCycles())

	// Add SS nodes.
	sss, err := model.GetSSForST(db, step.ID)
	if err != nil {
		logger.Error("Failed to retrieve SS for step", step.ID, ":", err)
		return Step{}, err
	}
	for _, ss := range sss {
		if err = g.AddVertex(ss.ID,
			graph.VertexAttribute("colorscheme", "ylorbr3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1")); err != nil {
			logger.Error("Failed to add SS node", ss.ID, "to subgraph for step", step.ID, ":", err)
		} else {
			logger.Debug("Added SS node", ss.ID, "to subgraph for step", step.ID)
		}
	}

	// Add dataset nodes used in this step.
	dts, err := model.GetDTsRelatedToSTviaSSs(db, step.ID)
	if err != nil {
		logger.Error("Failed to retrieve DTs for step", step.ID, ":", err)
		return Step{}, err
	}
	for _, dt := range dts {
		if err = g.AddVertex(dt.ID,
			graph.VertexAttribute("colorscheme", "blues3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1")); err != nil {
			logger.Error("Failed to add dataset node", dt.ID, "to subgraph for step", step.ID, ":", err)
		} else {
			logger.Debug("Added dataset node", dt.ID, "to subgraph for step", step.ID)
		}
	}

	// Process DT-SS relationships.
	relationships, err := model.GetDTSSRelationshipsForST(db, step.ID)
	if err != nil {
		logger.Error("Failed to retrieve DT-SS relationships for step", step.ID, ":", err)
		return Step{}, err
	}

	// For manual steps, add the step node and related dataset nodes/edges.
	if len(relationships) == 0 {
		if err = g.AddVertex(step.ID,
			graph.VertexAttribute("colorscheme", "greens3"),
			graph.VertexAttribute("style", "filled"),
			graph.VertexAttribute("color", "2"),
			graph.VertexAttribute("fillcolor", "1")); err != nil {
			logger.Error("Failed to add manual step node", step.ID, "to subgraph:", err)
		} else {
			logger.Debug("Added manual step node", step.ID, "to subgraph")
		}
		dtst, err := model.GetDTSTRelationships(db, step.ID)
		if err != nil {
			logger.Error("Failed to retrieve DT-ST relationships for manual step", step.ID, ":", err)
			return Step{}, err
		}
		for _, relationship := range dtst {
			if err = g.AddVertex(relationship.DTID,
				graph.VertexAttribute("colorscheme", "blues3"),
				graph.VertexAttribute("style", "filled"),
				graph.VertexAttribute("color", "2"),
				graph.VertexAttribute("fillcolor", "1")); err != nil {
				logger.Error("Failed to add dataset node", relationship.DTID, "to manual step subgraph", step.ID, ":", err)
			}
			labelText := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.STID
			switch relationship.RelationshipType {
			case "is input to", "is the input to", "is input from":
				if err = g.AddEdge(relationship.DTID, relationship.STID,
					graph.EdgeAttribute("label", relationship.RelationshipType),
					graph.EdgeAttribute("labeltooltip", labelText)); err != nil {
					logger.Warning("Failed to add edge", relationship.DTID, "->", relationship.STID, "in manual step subgraph", step.ID, ":", err)
				}
			case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
				if err = g.AddEdge(relationship.STID, relationship.DTID,
					graph.EdgeAttribute("label", relationship.RelationshipType),
					graph.EdgeAttribute("labeltooltip", labelText)); err != nil {
					logger.Warning("Failed to add edge", relationship.STID, "->", relationship.DTID, "in manual step subgraph", step.ID, ":", err)
				}
			default:
				logger.Warning("Unknown DT_ST relationship type:", relationship.RelationshipType)
			}
		}
	}

	// Process DT-SS relationships for non-manual steps.
	for _, relationship := range relationships {
		labelText := relationship.DTID + " - " + relationship.RelationshipType + " - " + relationship.SSID
		switch relationship.RelationshipType {
		case "is input to", "is the input to", "is input from":
			if err = g.AddEdge(relationship.DTID, relationship.SSID,
				graph.EdgeAttribute("label", relationship.RelationshipType),
				graph.EdgeAttribute("labeltooltip", labelText)); err != nil {
				logger.Warning("Failed to add edge", relationship.DTID, "->", relationship.SSID, "in subgraph", step.ID, ":", err)
			} else {
				logger.Debug("Added edge", relationship.DTID, "->", relationship.SSID, "in subgraph", step.ID)
			}
		case "is output to", "is updated by", "is the output from", "is generated by", "is output from":
			if err = g.AddEdge(relationship.SSID, relationship.DTID,
				graph.EdgeAttribute("label", relationship.RelationshipType),
				graph.EdgeAttribute("labeltooltip", labelText)); err != nil {
				logger.Warning("Failed to add edge", relationship.SSID, "->", relationship.DTID, "in subgraph", step.ID, ":", err)
			} else {
				logger.Debug("Added edge", relationship.SSID, "->", relationship.DTID, "in subgraph", step.ID)
			}
		default:
			logger.Warning("Unknown SS_DT relationship type:", relationship.RelationshipType)
		}
	}

	logger.Debug("Subgraph generated for step", step.ID)
	return Step{
		Id:    step.ID,
		Graph: g,
	}, nil
}

// SaveToFile writes workflow files (DOT and CWL) and RO-Crate metadata.
func (w *Workflow) SaveToFile(db *sql.DB) error {
	vertices, err := w.getVertices()
	if err != nil {
		logger.Error("Failed to retrieve vertices for workflow", w.Name, ":", err)
		return err
	}

	path := "workflows/" + w.Name + "/"
	for _, vertex := range vertices {
		if vertex.Graph == nil {
			logger.Debug("Skipping vertex", vertex.Id, "with no graph")
			continue
		}
		if err = os.MkdirAll(path, os.ModePerm); err != nil {
			logger.Error("Failed to create directory", path, ":", err)
			return err
		}

		file, err := os.Create(path + vertex.Id + ".dot")
		if err != nil {
			logger.Error("Failed to create file", path+vertex.Id+".dot", ":", err)
			return err
		}

		if err = draw.DOT(vertex.Graph, file); err != nil {
			logger.Error("Failed to save DOT file", path+vertex.Id+".dot", ":", err)
			return err
		}
		file.Close()
		logger.Debug("Saved DOT file for vertex", vertex.Id)

		cwlObj, err := StepToCWL(vertex, db)
		if err != nil {
			logger.Error("Failed to convert step", vertex.Id, "to CWL:", err)
			return err
		}
		if err = cwlObj.SaveToFile(path + vertex.Id + ".cwl"); err != nil {
			logger.Error("Failed to save CWL file for vertex", vertex.Id, ":", err)
			return err
		}
		logger.Debug("Saved CWL file for vertex", vertex.Id)
	}

	file, err := os.Create(path + w.Name + ".dot")
	if err != nil {
		logger.Error("Failed to create file", path+"steps.dot", ":", err)
		return err
	}
	defer file.Close()

	if err = draw.DOT(w.Graph, file); err != nil {
		logger.Error("Failed to save steps DOT file:", err)
		return err
	}

	cwlObj, err := WorkflowToCWL(*w, db)
	if err != nil {
		logger.Error("Failed to convert workflow", w.Name, "to CWL:", err)
		return err
	}
	if err = cwlObj.SaveToFile(path + w.Name + ".cwl"); err != nil {
		logger.Error("Failed to save workflow CWL file", path+w.Name+".cwl", ":", err)
		return err
	}
	logger.Debug("Saved workflow CWL file", path+w.Name+".cwl")

	crate, err := rocrate.WorkflowToRoCrate(w.Name, cwlObj, db)
	if err != nil {
		logger.Error("Failed to generate RO-Crate for workflow", w.Name, ":", err)
		return err
	}
	if err = crate.SaveToFile(path + "ro-crate-metadata.json"); err != nil {
		logger.Error("Failed to save RO-Crate metadata file", path+"ro-crate-metadata.json", ":", err)
		return err
	}
	logger.Debug("Saved RO-Crate metadata file", path+"ro-crate-metadata.json")

	return nil
}

// getVertices returns all non-dataset vertices from the workflow graph.
func (w *Workflow) getVertices() ([]Step, error) {
	adjMap, err := w.Graph.AdjacencyMap()
	if err != nil {
		logger.Error("Failed to retrieve adjacency map for workflow", w.Name, ":", err)
		return nil, err
	}

	var vertices []Step
	for hash := range adjMap {
		vertex, err := w.Graph.Vertex(hash)
		if err != nil {
			logger.Error("Failed to retrieve vertex", hash, ":", err)
			continue
		}
		if vertex.Graph == nil {
			logger.Debug("Skipping dataset vertex", hash)
			continue
		}
		vertices = append(vertices, vertex)
	}
	logger.Debug("Collected", len(vertices), "vertices for workflow", w.Name)
	return vertices, nil
}

// getVertices categorizes the vertices of a step's graph into DT, ST, and SS.
func (s *Step) getVertices() (dts []string, sts []string, sss []string, err error) {
	adjMap, err := s.Graph.AdjacencyMap()
	if err != nil {
		logger.Error("Failed to retrieve adjacency map for step", s.Id, ":", err)
		return nil, nil, nil, err
	}

	dts = make([]string, 0, len(adjMap))
	sts = make([]string, 0, len(adjMap))
	sss = make([]string, 0, len(adjMap))
	for hash := range adjMap {
		vertex, err := s.Graph.Vertex(hash)
		if err != nil {
			logger.Error("Failed to retrieve vertex", hash, "for step", s.Id, ":", err)
			continue
		}

		if strings.Contains(vertex, "DT") {
			dts = append(dts, vertex)
		}
		if strings.Contains(vertex, "ST") {
			sts = append(sts, vertex)
		}
		if strings.Contains(vertex, "SS") {
			sss = append(sss, vertex)
		}
	}
	logger.Debug("Step", s.Id, "has", len(dts), "DTs,", len(sts), "STs, and", len(sss), "SSs")
	return dts, sts, sss, nil
}
